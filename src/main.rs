#![allow(unused)]
use crate::Number::Int;
use crate::Type::Float as Float_type;
use crate::Type::Int as Int_type;
use ariadne::{Color, Label, Report, ReportKind, Source};
use ast::BinaryOp;
use ast::Block;
use ast::MathOp;
use ast::{
    i32_to_f32, Expression, Instruction, Number, Statement, ToInstruction, Token, Type, Value,
    Variable,
};
use chumsky::prelude::*;
use chumsky::text::keyword;
mod ast;
mod compiler;
use std::io;
pub type Span = SimpleSpan<usize>;

fn main() {
    let input_verified = r#"use io::print
    x = xÃ¶la
    y = 69 / (56 - 0.45)
    print(Works?)
    enum Foo:
        baz
    ;
    struct baz:
        lmao: int,
        lmao2: int
    ;
    int add (int: x, int: y) (
        x + y
    // 
    add (4,5).sqrt
    
    if x == 4  (
        print ("oooops!")
    ) else (
        print ("phew")
    )"#;
    let quit = false;
    while !quit {
        let mut temp_input = String::new();
        io::stdin()
            .read_line(&mut temp_input)
            .expect("Failed to read line");
        if temp_input == "q" {
            return;
        }
        let parsed = match lexer().parse(&temp_input).into_output() {
            Some(n) => println!("{:?}",n),
            None => eprintln!("Yupp! U fucked it.")
        };
    }
}
fn lexer<'src>(
) -> impl Parser<'src, &'src str, Vec<(Token<'src>, Span)>, extra::Err<Rich<'src, char, Span>>> {
    // A parser for numbers
    let num = text::int(10)
        .then(just('.').then(text::digits(10)).or_not())
        .slice()
        .from_str()
        .unwrapped()
        .map(Token::Num);

    // A parser for strings
    let str_ = just('"')
        .ignore_then(none_of('"').repeated())
        .then_ignore(just('"'))
        .map_slice(Token::String);

    // A parser for operators
    let op = one_of("+*-/!=\n")
        .repeated()
        .at_least(1)
        .map_slice(Token::Op);

    // A parser for control characters (delimiters, semicolons, etc.)
    let ctrl = one_of("()[]:;,").map(Token::Delimiter);

    // A parser for identifiers and keywords
    let ident = text::ident().map(|ident: &str| match ident {
        "fn" => Token::Fn,
        "if" => Token::If,
        "else" => Token::Else,
        "true" => Token::Bool(true),
        "false" => Token::Bool(false),
        "struct" => Token::Struct,
        "enum" => Token::Enum,
        "import" => Token::Import,
        "::" => Token::PathSeperator,
        "int" => Token::Type(Type::Int),
        "float" => Token::Type(Type::Float),
        "string" => Token::Type(Type::String),
        "bool" => Token::Type(Type::Bool),
        "char" => Token::Type(Type::Char),
        _ => Token::Ident(ident),
    });

    // A single token can be one of the above
    let token = num.or(str_).or(op).or(ctrl).or(ident);

    let comment = just("//")
        .then(any().and_is(just('\n').not()).repeated())
        .padded();

    token
        .map_with_span(|tok, span| (tok, span))
        .padded_by(comment.repeated())
        .padded()
        // If we encounter an error, skip and attempt to lex the next character as a token instead
        .recover_with(skip_then_retry_until(any().ignored(), end()))
        .repeated()
        .collect()
}
// The type of the input that our parser operates on. The input is the `&[(Token, Span)]` token buffer generated by the
// lexer, wrapped in a `SpannedInput` which 'splits' it apart into its constituent parts, tokens and spans, for chumsky
// to understand.
type ParserInput<'tokens, 'src> =
    chumsky::input::SpannedInput<Token<'src>, Span, &'tokens [(Token<'src>, Span)]>;

//          chumsky::input::SpannedInput<Token, Span, &[(Token, Span)]>;
// This looks complex, but don't be scared!
//
// There are two lifetimes here:
//     - 'tokens: the lifetime of the token buffer emitted by the lexer
//     - 'src: the lifetime of the underlying source code (the string we read from disk)
// Our source code lives longer than the token buffer, hence `'src: 'tokens`
//
// From this function, we return a parser that parses an input of type `ParserInput` (see above for an explanation of
// that) and produces a `Spanned<Expr>` (an expression with a span attached to it, so we can point to the right thing
// for runtime errors).

pub type Spanned<T> = (T, Span);
fn parser<'tokens, 'src: 'tokens>() -> impl Parser<
    'tokens,
    ParserInput<'tokens, 'src>,
    Spanned<Instruction<'src>>,
    extra::Err<Rich<'tokens, Token<'src>, Span>>,
> + Clone {
    let ident = select! { Token::Ident(ident) => ident.clone().to_string() }.labelled("identifier");
    let num = select! { Token::Num(v) => v.clone() }.labelled("number");
    let import = just(Token::Import)
        .ignore_then(ident)
        .then_ignore(just(Token::PathSeperator))
        .repeated()
        .collect::<Vec<_>>()
        .then(ident)
        .map_with_span(|(module, name), span:_| -> (Instruction, Span) {
            (Instruction::Statement(Box::new(Statement::Import(module, name))), span)
        });
    let r#type = recursive(|r#type| {
        let primitives = one_of([
            Token::Type(Type::Bool),
            Token::Type(Type::Char),
            Token::Type(Type::Float),
            Token::Type(Type::Int),
            Token::Type(Type::Span),
        ]).map(|token| -> Type {
                if let Token::Type(typee) = token { 
                    typee
                } else {
                    unreachable!()
                }
            });

        let tuple = r#type.clone()
            .separated_by(just(delim!(',')))
            .collect::<Vec<_>>()
            .delimited_by(just(Token::Delimiter('(')), just(delim!(')')))
            .map(Type::Tuple);
        let array = r#type.clone()
            .then_ignore(just(Token::Delimiter(',')))
            .then(num)
            .delimited_by(just(delim!("[")),just(delim!("]")))
            .map(|(r#type,len)| Type::Array(Box::new(r#type),len));
        choice((tuple,primitives,array))
    });
    let colon = just(Token::Delimiter(':'));
    let struct_field = ident
        .then_ignore(colon.clone())
        .then(r#type)
        .map(|(name, r#type)| ast::StructField { name, r#type });
    let r#struct = just(Token::Struct)
        .ignore_then(ident)
        .then_ignore(colon)
        .then(
            struct_field
                .separated_by(just(delim!(',')))
                .collect::<Vec<_>>()
        )
        .map_with_span(|(struct_name, fields),span| (ast::Statement::StructDeclaration {
            name: struct_name,
            fields,
        }.to_instruction(),span));
    choice((r#struct,import)).then_ignore(end())
}
//fn parser() -> impl Parser<'static, char, Expression, Simple<'static, char>> {
//    let ident = text::ident()
//                .padded();
//
//    let expression = recursive(|expression| {
//
//        let int = text::int(10)
//                    .then(just('.').then(text::digits(10)).or_not())
//                    .slice()
//                    .from_str()
//                    .unwrapped()
//                    .map(|num,num2| Value::Number(Int(num.parse().unwrap())).to_Expression(Int_type))
//                    .padded();
//
//        let float = text::int(10)
//            .separated_by(just('.'))
//            .exactly(2)
//            .map(|float| -> Expression{
//                let nums: _ = float
//                    .to_owned()
//                    .iter()
//                    .map(|num| -> i32 {if let Ok(n) = num.parse() { n } else { 0 }})
//                    .collect::<Vec<i32>>();
//
//                    Value::Number(Number::Float(i32_to_f32(nums[0], nums[1])))
//                        .to_Expression(Float_type)
//                });
//
//        let string = ident.delimited_by(just("\""),just("\""));
//
//        let number = float.or(int);
//
//        let atom = number.or(expression.delimited_by(just("("), just(")")))
//            .or(ident.map(|var| -> Expression { Expression::Variable(var).to_owned().to_Expression(Type::Inferred) }));
//        let operator = |char| just(char).padded();
//        let unary = operator('-')
//            .repeated()
//            .then(atom)
//            .foldr(|_operator, rhs| rhs.to_UnaryMathExpression());
//
//        let product = unary
//            .clone()
//            .then(
//                operator('*')
//                    .to(Expression::Mul as fn(_, _) -> ExpressionType)
//                    .or(operator('/').to(Expression::Div as fn(_, _) -> ExpressionType))
//                    .then(unary.clone())
//                    .repeated(),
//            )
//            .foldl(|lhs, (op, rhs)| -> Expression {
//                op(Box::new(lhs), Box::new(rhs)).to_Expression(Type::Int)
//            });
//
//        let addition = product
//            .clone()
//            .then(
//                operator('-')
//                    .to(Expression::Sub as fn(_, _) -> ExpressionType)
//                    .or(operator('+').to(Expression::Add as fn(_, _) -> ExpressionType))
//                    .then(product)
//                    .repeated(),
//            )
//            .foldl(|lhs, (op, rhs)| -> Expression {
//                op(Box::new(lhs), Box::new(rhs)).to_Expression(Type::Int)
//            });
//        addition
//    });
//    let decl = recursive(|_decl| {
//        let assignment = ident
//            .then_ignore(just('='))
//            .then(expression.clone())
////            .then_ignore(text::newline())
//            .map(|(name, rhs)|{
//                let var = Statement::VariableDeclaration(Variable {
//                    name,
//                    value: Box::new(rhs.clone()),
//                    r#type: rhs.return_type.clone()
//                });
//                var.to_Expression(Type::Inferred)
//            });
//        assignment.or(expression).padded()
//    });
//    decl.then_ignore(end())
//}
#[macro_export]
macro_rules! delim {
    ($x:expr) => {
        Token::Delimiter($x.to_string().chars().next().unwrap())
    };
}

#[cfg(test)]
mod tests;
